---
title: "Metropolis algorithm for N layers."
output: html_notebook

---
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 
Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

It is recommended to read the user manual before executing. 


```{r include=FALSE}
dependencies <- c(
  "devtools",
  "dplyr",
  "deldir",
  "ggplot2",
  "plotly",
  "foreach",
  "doParallel")
  #"ggvoronoi",
  #"gganimate")

for(dep in dependencies){
  if(!require(dep, character.only = TRUE)){
    install.packages(dep)
  }
}
```

# Execute 1 simulation

## Run the simulation
The function that performs Metropolis Algorithm is called "perform_simulations". With the same function we can perform both "static" and "bending" simulations.
```{r}
PATH_MODEL = "tubular_simulations_source/model_execution.R"
source(PATH_MODEL)

choose_algorithm <- "static"

params = list(
  seed = 1, # randomness
  n_steps = 20, # simulation steps
  n_cells = 100, # number of cells
  n_layers = 3, # numbers of layers (min 3)
  apical_rad = 5/(2*pi), # apical radius
  ratio_rad = 2.5, # ratio between apical and basal radius 
  cyl_length = 20, # cylinder length
  gamma = 0.15, #3  contractility
  lambda = 0.04, # adhesion 
  # elastic kappa = 1 cause adimentionality
  beta = 100, #constant involved in jumps because of perturbations
  s0_ratio = 1 # characteristic ratio between the actual radius and apical radius
  #BENDING
  #,omega = 1 #bending constant
  )

start.time <- Sys.time()

simulation <- perform_simulations(algorithm="choose_algorithm",parameters=params) 

end.time <- Sys.time()
time.taken <- end.time - start.time
print(paste("Execution Time:", time.taken))
print(paste("Execution Time:", round(as.numeric(time.taken, units="min"), 2), "mins"))

result_alg <- simulation$results
parameters <- simulation$parameters
algorithm <- simulation$algorithm
```

You can check that the results had been properly saved in your folder. 

## Save Tesselation for 3D plots

Now, we select the tessellation that we want to save. Then, to do the 3D plots, we use the Mathematica file with this input.
```{r}{r include=FALSE}
saveFrame <-  parameters$n_steps # last frame is parameters$n_steps

library(dplyr) # to do the filtering operation in the dataframe
dir.create(file.path("saved_tessellations/"))
PATH_FUNCTIONS = "tubular_simulations_source/save_utils.R"
source(PATH_FUNCTIONS)

points <- filter(result_alg[[1]], Frame == saveFrame)
pts_info = save_tessellation_layers(points, n = parameters$n_cells, RadiusA =parameters$apical_rad, Ratio = parameters$ratio_rad,
                                     cyl_length = parameters$cyl_length, Layers = parameters$n_layers,
                                     filename = paste0("saved_tessellations/saved_tessellation_frame",saveFrame,".csv"))
```

## Loading results

To load pre-existing results:
```{r}
# CHANGE file_name WITH THE CORRESPONDING PATH (check the folder results)
filename <- "results/static/results_simulation_24_10_25.RData"
simulation <- load_results(filename)

result_alg <- simulation$results
parameters <- simulation$parameters
algorithm <- simulation$algorithm
```

## Data analysis 1 simulation

### Dataframe with history of points and energy levels

Results are stored in the variable "result_alg". This variable has 2 elements: the history of points locations in every step ("hist_point"), the history of the energy at every step ("hist_energy").

- "hist_points": each row represents a point, the columns "x" and "y" represent the x and y coordinates of the point, and the column "Frame" represents the step of the algorithm. Number of rows = n_steps x n_cells

- "hist_energy" contains simply 2 columns, one indicating the iteration (or step) and other indicating the energy after performing that number of iterations of Metropolis. Number of rows = n_steps.

It is necessary to generate this data to perform the following analysis. 

```{r}
# Points
hist_points = result_alg$points_evolution
knitr::kable(hist_points[1:10,], format="html") # Vizualization of the 10 first rows

# Energy
hist_energy = result_alg$energy_evolution
knitr::kable(hist_energy[1:10,], format="html") 
```

### Energy levels plot 

The function "energy_analisis_1sim" takes as argument the points in each iteration ("hist_points") generated previously and returns the energy shelled by type in each iteration (an extension of the energy history). The 4 columns represent the elastic, contractile, tensile energy and total energy (sum of all). The function "energy_analysis_nobend" takes as argument the history of points and returns the plots of the energies at the initial step and at the final step, depending on the layer.

```{r}
PATH_ANALYSIS = "tubular_simulations_source/source_analysis.R"
source(PATH_ANALYSIS)

# Average energies over time
enerhist_total <- energy_analisis_1sim(hist_points, it = parameters$n_steps, lay = parameters$n_layers, n = parameters$n_cells)
plot_energyss(enerhist_total)
knitr::kable(enerhist_total[1:10,], format="html") 

# Energies per layer
results_analysis <- energy_analysis_nobend(histpts = hist_points, it = parameters$n_steps, n = parameters$n_cells, Lay = parameters$n_layers)
initial_energies <- results_analysis[[1]]
final_energies <- results_analysis[[2]]

# Over time
hist_layers <- energy_layers_sim1(histpts = hist_points, it = parameters$n_steps, Lay = parameters$n_layers, n = parameters$n_cells) 
knitr::kable(hist_layers[1:3,], format="html")
plot_energy_decomp(hist_layers)
```



# Parallel simulations

## Execution 
Parallel execution to execute multiple simulations at the same time. Usually, we choose 3 clusters (the default number of cores in ordinary laptops). 

```{r include=FALSE}
library(foreach)
library(doParallel)

PATH_MODEL = "tubular_simulations_source/model_execution.R"
source(PATH_MODEL)

N_SIM = 10 # number of simulations
N_CLUSTERS = 20 # number of clusters
cl <- makeCluster(N_CLUSTERS) 
registerDoParallel(cl)

start.time <- Sys.time()

par_results <- foreach(i=c(1,2,3,4,5,6,7,8,9,10), .combine = rbind, .packages = "deldir") %dopar% {
  
 params = list(
  seed = i, # randomness
  n_steps = 20, # simulation steps
  n_cells = 100, # number of cells
  n_layers = 3, # numbers of layers (min 3)
  apical_rad = 5/(2*pi), # apical radius
  ratio_rad = 2.5, # ratio between apical and basal radius 
  cyl_length = 20, # cylinder length
  gamma = 0.15, #3  contractility
  lambda = 0.04, # adhesion 
  # elastic kappa = 1 cause adimentionality
  beta = 100, #constant involved in jumps because of perturbations
  s0_ratio = 1 # characteristic ratio between the actual radius and apical radius
  #BENDING
  #,omega = 1 #bending constant
  )

  do.call(perform_simulations,list(algorithm="static", parameters=params,save_parallel=TRUE))
}

end.time <- Sys.time()
time.taken <- end.time - start.time
print(paste("Execution Time:", time.taken))
print(paste("Execution Time:", round(as.numeric(time.taken, units="mins"), 2), "mins"))

stopCluster(cl)
stopImplicitCluster()

```

## Analysis parralel simulations

### Structure of the dataframe "par_results"

Results are stored in the variable "par_results". This variable has N_SIM elements of 3 elements each one (results, parameters and algorithm). Each element has "n_cells" rows et "n_steps" columns.

```{r}{r include=FALSE}
# Access information about the simulation 3
hist_points_sim_3 = par_results[[3,1]]$points_evolution
parameters_sim_3 = par_results[[3,2]]$parameters
```

The following functions work only for parallel simulations using same number of cells and same number of steps. 

```{r}
PATH_SIMANALYSIS = "tubular_simulations_source/source_simulation_analysis.R"
source(PATH_SIMANALYSIS)

# Reorganize all the simulations
resord <- ord(par_results, iter = par_results[[1,2]]$n_steps, n=par_results[[1,2]]$n_cells, sim = N_SIM)

# Average number of neighbors in basal surface
Am <- (2*pi*par_results[[1,2]]$apical_rad*(par_results[[1,2]]$cyl_length))/par_results[[1,2]]$n_cells
edgearsim<-funaux2simDOUBLE(resord,n=par_results[[1,2]]$n_cells,ps=N_SIM, A0=Am)
stationarylewis(edgearsim[[1]][1:(par_results[[1,2]]$n_cells*N_SIM),c(1,2)]) #DOESNT WORK

# I dont know what it is doing and doesnt work
stationarylewis(edgearsim[[1]][1:10000,c(1,2,3)])
stationarylewis(edgearsim[[2]][1:10000,c(1,2,3)])
```


```{r}
# Average energy relaxation
adjsim(par_results,nsim=N_SIM,it=par_results[[1,2]]$n_steps)

xmin<-0
xmax<-5
ymin<-0
ymax<-20
rec1 <- c(xmin,xmin+3*xmax,ymin,ymax)
rec2 <- c(xmin,xmin+3*(xmax*2.5),ymin,ymax)

scutoids_prep(points$x,points$y,(2.5)*points$x,points$y,rect1= rec1,rect2=rec2)
scutoids_analysis_oneiter(points$x,points$y,(2.5)*points$x,points$y,rect1= rec1,rect2=rec2)
df_scutoid <- scutoids_analysis_simulations(result_alg)
```
