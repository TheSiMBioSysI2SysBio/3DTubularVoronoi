---
title: "Metropolis algorithm for N layers."
output: html_notebook

---
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 
Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

It is recommended to read the user manual before executing. 


```{r include=FALSE}
dependencies <- c(
  "devtools",
  "dplyr",
  "deldir",
  "ggplot2",
  "plotly",
  "foreach",
  "doParallel")
  #"ggvoronoi",
  #"gganimate")

for(dep in dependencies){
  if(!require(dep, character.only = TRUE)){
    install.packages(dep)
  }
}
```

# Execute 1 simulation

## Run the simulation
The function that performs Metropolis Algorithm is called "perform_simulations". 

```{r}
PATH_MODEL = "tubular_simulations_source/model_execution.R"
source(PATH_MODEL)

params = list(
  seed = 1, # randomness
  n_steps = 100, # simulation steps
  n_cells = 100, # number of cells
  n_layers = 6, # numbers of layers (min 3)
  apical_rad = 5/(2*pi), # apical radius
  ratio_rad = 2.5, # ratio between apical and basal radius 
  cyl_length = 20, # cylinder length
  gamma = 0.15, #3  contractility
  lambda = 0.04, # adhesion 
  #kappa = 1 cause adimentionality (elasticity)
  beta = 100, #constant involved in jumps because of perturbations
  s0_ratio = 1 # characteristic ratio between the actual radius and apical radius
  #BENDING
  #,omega = 1 #bending constant
  )

start.time <- Sys.time()

simulation <- perform_simulations(algorithm="static",parameters=params) 

end.time <- Sys.time()
time.taken <- end.time - start.time
print(paste("Execution Time:", round(as.numeric(time.taken, units="mins"), 2), "mins"))

result_alg <- simulation$results
parameters <- simulation$parameters
algorithm <- simulation$algorithm
```

You can check that the results had been properly saved in your folder. 

## Save Tesselation for 3D plots

Now, we select the tessellation that we want to save. Then, to do the 3D plots, we use the Mathematica file with this input.

```{r} 

saveFrame <-  parameters$n_steps # last frame is parameters$n_steps

library(dplyr) # to do the filtering operation in the dataframe
dir.create(file.path("saved_tessellations/"))
PATH_FUNCTIONS = "tubular_simulations_source/save_utils.R"
source(PATH_FUNCTIONS)

points <- filter(result_alg[[1]], Frame == saveFrame)
pts_info = save_tessellation_layers(points, n = parameters$n_cells, RadiusA =parameters$apical_rad, Ratio = parameters$ratio_rad,
                                     cyl_length = parameters$cyl_length, Layers = parameters$n_layers,
                                     filename = paste0("saved_tessellations/saved_tessellation_frame",saveFrame,".csv"))
```

## Loading results

To load pre-existing results:
```{r}
# CHANGE file_name WITH THE CORRESPONDING PATH (check the folder results)
filename <- "results/static/results_simulation_24_10_25.RData"
simulation <- load_results(filename)

result_alg <- simulation$results
parameters <- simulation$parameters
algorithm <- simulation$algorithm
```

## Data analysis 1 simulation

### Dataframe with history of points and energy levels

Results are stored in the variable "result_alg". This variable has 2 elements: the history of points locations in every step ("hist_point"), the history of the energy at every step ("hist_energy").

- "hist_points": each row represents a point, the columns "x" and "y" represent the x and y coordinates of the point, and the column "Frame" represents the step of the algorithm. Number of rows = n_steps x n_cells

- "hist_energy" contains simply 2 columns, one indicating the iteration (or step) and other indicating the energy after performing that number of iterations of Metropolis. Number of rows = n_steps.

It is necessary to generate this data to perform the following analysis. 

```{r}
# Points
hist_points = result_alg$points_evolution
knitr::kable(hist_points[1:10,], format="html") # Vizualization of the 10 first rows

# Energy
hist_energy = result_alg$energy_evolution
knitr::kable(hist_energy[1:10,], format="html") 
```

### Energy levels plot 

The function "energy_analisis_1sim" takes as argument the points in each iteration ("hist_points") generated previously and returns the energy shelled by type in each iteration (an extension of the energy history). The 4 columns represent the elastic, contractile, tensile energy and total energy (sum of all). The function "energy_analysis_nobend" takes as argument the history of points and returns the plots of the energies at the initial step and at the final step, depending on the layer.

```{r}
PATH_ANALYSIS = "tubular_simulations_source/source_analysis.R"
source(PATH_ANALYSIS)

# Average energies over time
enerhist_total <- energy_analisis_1sim(hist_points, it = parameters$n_steps, lay = parameters$n_layers, n = parameters$n_cells)
plot_energyss(enerhist_total)
knitr::kable(enerhist_total[1:10,], format="html") 

# Energies per layer
results_analysis <- energy_analysis_nobend(histpts = hist_points, it = parameters$n_steps, n = parameters$n_cells, Lay = parameters$n_layers)
initial_energies <- results_analysis[[1]]
final_energies <- results_analysis[[2]]

# Over time
hist_layers <- energy_layers_sim1(histpts = hist_points, it = parameters$n_steps, Lay = parameters$n_layers, n = parameters$n_cells) 
knitr::kable(hist_layers[1:3,], format="html")
plot_energy_decomp(hist_layers)
```

### Scutoids

Count number of scutoids. A warning message can appear when data is out of the scope. 

```{r}
PATH_ANALYSIS = "tubular_simulations_source/source_simulation_analysis.R"
source(PATH_ANALYSIS)

# Collect data of last frame
points <- filter(result_alg$points_evolution, Frame == parameters$n_steps)

# Plot scutoids table count
scutoids_analysis_oneiter(points$x,points$y,(parameters$ratio_rad)*points$x,points$y,ratio=parameters$ratio_rad,ap_rad = parameters$apical_rad, n = parameters$n_cells,cylen = parameters$cyl_length)
```


```{r}
# Neighbors
PATH_ANALYSIS = "tubular_simulations_source/source_simulation_analysis.R"
source(PATH_ANALYSIS)

# Average number of neighbors 
edgear <- funaux2simDOUBLE(result_alg$points_evolution,ps=1,n=parameters$n_cells, cylen = parameters$cyl_length,apical_radius = parameters$apical_rad)
#apical area
stationarylewisApical(edgear[[1]][1:parameters$n_cells,c(1,2,3)])
#basal area
stationarylewisBasal(edgear[[2]][1:parameters$n_cells,c(1,2,3)])
 
```

# Parallel simulations

## Execution 
Parallel execution to execute multiple simulations at the same time. Usually, we choose 3 clusters (the default number of cores in ordinary laptops). 

```{r include=FALSE}
library(foreach)
library(doParallel)

PATH_MODEL = "tubular_simulations_source/model_execution.R"
source(PATH_MODEL)

N_SIM = 10 # number of simulations
N_CLUSTERS = 20 # number of clusters
cl <- makeCluster(N_CLUSTERS) 
registerDoParallel(cl)

start.time <- Sys.time()

par_results <- foreach(i= 1:N_SIM, .combine = rbind, .packages = "deldir") %dopar% {
  
 params = list(
  seed = i, # randomness
  n_steps = 100, # simulation steps
  n_cells = 100, # number of cells
  n_layers = 6, # numbers of layers (min 3)
  apical_rad = 5/(2*pi), # apical radius
  ratio_rad = 2.5, # ratio between apical and basal radius 
  cyl_length = 20, # cylinder length
  gamma = 0.15, #3  contractility
  lambda = 0.04, # adhesion 
  #kappa = 1 cause adimentionality (elasticity)
  beta = 100, #constant involved in jumps because of perturbations
  s0_ratio = 1 # characteristic ratio between the actual radius and apical radius
  #BENDING
  #,omega = 1 #bending constant
  )

  do.call(perform_simulations,list(algorithm="static", parameters=params,save_parallel=TRUE))
}

end.time <- Sys.time()
time.taken <- end.time - start.time
print(paste("Execution Time:", round(as.numeric(time.taken, units="mins"), 2), "mins"))

stopCluster(cl)
stopImplicitCluster()

par_parameters <- par_results[[1,2]]
```

## Loading results

To load pre-existing results:
```{r}
PATH_MODEL = "tubular_simulations_source/model_execution.R"
source(PATH_MODEL)

par_results <- NULL # uncomment this if you want to load data (security)
N_SIM = 10

for(i in 1:N_SIM){
  filename <- paste0("results/parallel/results_simulation_25_01_18_",i,".RData")
  
  # Extract  
  simulation_i <- load_results(filename)
  results_i <- simulation_i$results
  parameters_i <- simulation_i$parameters
  algorithm_i <- simulation_i$algorithm
  # Build the array
  par_results <- rbind(par_results, list(results = results_i, parameters = parameters_i, algorithm = algorithm_i))
}
par_parameters <- par_results[[1,2]]
```


## Analysis parralel simulations

### Structure of the dataframe "par_results"

Results are stored in the variable "par_results". This variable has N_SIM elements of 3 elements each one (results, parameters and algorithm). Each element has "n_cells" rows et "n_steps" columns.

```{r}{r include=FALSE}
# Access information about the simulation 3
hist_points_sim_3 = par_results[[3,1]]$points_evolution
```

The following functions work only for parallel simulations using same number of cells and same number of steps. 

```{r}
PATH_SIMANALYSIS = "tubular_simulations_source/source_simulation_analysis.R"
source(PATH_SIMANALYSIS)

# Reorganize all the simulations
resord <- ord(par_results, iter = par_parameters$n_steps, n=par_parameters$n_cells, sim = N_SIM)

# Average number of neighbors in basal surface
edgearsim <- funaux2simDOUBLE(resord,n=par_parameters$n_cells,ps=N_SIM,cylen = par_parameters$cyl_length, apical_radius = par_parameters$apical_rad, Ratio = par_parameters$ratio_rad)

# Average number of neighbors in the apical area
stationarylewisApical(edgearsim[[1]][1:(par_parameters$n_cells*N_SIM),c(1,2,3)])  
# Average number of neighbors in the basal area
stationarylewisBasal(edgearsim[[2]][1:(par_parameters$n_cells*N_SIM),c(1,2,3)])  

```


```{r}
PATH_SIMANALYSIS = "tubular_simulations_source/source_simulation_analysis.R"
source(PATH_SIMANALYSIS)

# Average energy relaxation and regression6
adjsim(par_results,nsim=N_SIM,it=par_parameters$n_steps)
```

```{r}
PATH_SIMANALYSIS = "tubular_simulations_source/source_simulation_analysis.R"
source(PATH_SIMANALYSIS)

# Scutoids table
scutoids_analysis_simulations(par_results, it = par_parameters$n_steps, sim = N_SIM, n = par_parameters$n_cells,cylen = par_parameters$cyl_length,ap_rad = par_parameters$apical_rad, Ratio = par_parameters$ratio)

```
